rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    // Since you're using password protection, you can customize this
    function isAuthenticated() {
      // For now, allowing access for the two users only
      // You could enhance this with Firebase Auth later
      return true;
    }
    
    // Helper function to check if user is one of the two partners
    function isValidUser(userId) {
      return userId == 'ndg' || userId == 'ak';
    }
    
    // Pings Collection - Real-time ping notifications
    match /pings/{pingId} {
      // Allow read for all authenticated users (both partners can see pings)
      allow read: if isAuthenticated();
      
      // Allow create only with valid data structure
      allow create: if isAuthenticated() 
        && request.resource.data.keys().hasAll(['from', 'to', 'type', 'message', 'timestamp'])
        && isValidUser(request.resource.data.from)
        && isValidUser(request.resource.data.to)
        && request.resource.data.from != request.resource.data.to
        && request.resource.data.type is string
        && request.resource.data.message is string;
      
      // Allow update only to mark as read
      allow update: if isAuthenticated()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read'])
        && request.resource.data.read is bool;
      
      // Allow delete only for pings older than 7 days
      allow delete: if isAuthenticated()
        && request.time > resource.data.timestamp + duration.value(7, 'd');
    }
    
    // Moments Collection - Photo gallery with captions
    // NOTE: Images stored as base64 data (NO Firebase Storage costs!)
    match /moments/{momentId} {
      // Allow read for all authenticated users
      allow read: if isAuthenticated();
      
      // Allow create only with valid data structure
      allow create: if isAuthenticated()
        && request.resource.data.keys().hasAll(['imageData', 'caption', 'uploadedBy', 'timestamp'])
        && isValidUser(request.resource.data.uploadedBy)
        && request.resource.data.imageData is string
        && request.resource.data.imageData.matches('^data:image/(jpeg|jpg|png|gif|webp|heic|heif);base64,.*')
        && request.resource.data.imageData.size() <= 1400000 // ~1MB base64 limit (Firestore has 1MB doc limit)
        && request.resource.data.caption is string
        && request.resource.data.caption.size() <= 500
        && request.resource.data.timestamp == request.time;
      
      // Allow update only for caption editing
      allow update: if isAuthenticated()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['caption'])
        && request.resource.data.caption is string
        && request.resource.data.caption.size() <= 500;
      
      // Allow delete for authenticated users
      allow delete: if isAuthenticated();
    }
    
    // Letters Collection (if you add this feature later)
    match /letters/{letterId} {
      // Allow read for all authenticated users
      allow read: if isAuthenticated();
      
      // Allow create only with valid data structure
      allow create: if isAuthenticated()
        && request.resource.data.keys().hasAll(['content', 'from', 'to', 'date', 'timestamp'])
        && isValidUser(request.resource.data.from)
        && isValidUser(request.resource.data.to)
        && request.resource.data.content is string
        && request.resource.data.content.size() <= 5000
        && request.resource.data.timestamp == request.time;
      
      // Allow update for marking as read
      allow update: if isAuthenticated()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read'])
        && request.resource.data.read is bool;
      
      // Allow delete by the original author
      allow delete: if isAuthenticated();
    }
    
    // Hugs/Messages Collection (if you add this feature later)
    match /hugs/{hugId} {
      // Allow read for all authenticated users
      allow read: if isAuthenticated();
      
      // Allow create with valid structure
      allow create: if isAuthenticated()
        && request.resource.data.keys().hasAll(['message', 'from', 'to', 'timestamp'])
        && isValidUser(request.resource.data.from)
        && isValidUser(request.resource.data.to)
        && request.resource.data.message is string
        && request.resource.data.timestamp == request.time;
      
      // No updates allowed for hugs (they're immutable)
      allow update: if false;
      
      // Allow delete by the sender or after 30 days
      allow delete: if isAuthenticated()
        && (request.time > resource.data.timestamp + duration.value(30, 'd'));
    }
    
    // User Preferences and FCM Tokens
    match /users/{userId} {
      // Only allow the specific user to read their own data
      allow read: if isAuthenticated() 
        && isValidUser(userId);
      
      // Allow creating user document with valid userId
      allow create: if isAuthenticated() 
        && isValidUser(userId)
        && request.resource.data.keys().hasAll(['fcmToken', 'platform', 'lastUpdated']);
      
      // Allow updating FCM token and platform (for token refreshes)
      allow update: if isAuthenticated() 
        && isValidUser(userId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['fcmToken', 'platform', 'lastUpdated']);
      
      // Allow delete for cleanup
      allow delete: if isAuthenticated() 
        && isValidUser(userId);
    }
    
    // Block all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
